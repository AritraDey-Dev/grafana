import { tool } from '@langchain/core/tools';
import { lastValueFrom } from 'rxjs';
import { z } from 'zod';

import { CoreApp, dateTime, makeTimeRange } from '@grafana/data';
import { PrometheusDatasource } from '@grafana/prometheus';
import { getDatasourceSrv } from 'app/features/plugins/datasource_srv';

import { buildPanelJson } from './buildPanelJson';
import { summarizePrometheusQueryResult } from './prometheusQuerySummarizer';
import { prometheusTypeRefiner, unixTimestampRefiner } from './refiners';

const prometheusRangeQuerySchema = z.object({
  datasource_uid: z
    .string()
    .describe('The datasource UID datasource, only support Prometheus compatible datasource')
    .refine(prometheusTypeRefiner.func, prometheusTypeRefiner.message),
  query: z.string().describe('(REQUIRED) The PromQL query expression to evaluate'),
  start: z
    .number()
    .describe('Start timestamp for the query range (Unix millisecond timestamp)')
    .refine(unixTimestampRefiner.func, unixTimestampRefiner.message),
  end: z
    .number()
    .describe('End timestamp for the query range (Unix millisecond timestamp')
    .refine(unixTimestampRefiner.func, unixTimestampRefiner.message),
  step: z.string().describe('Query resolution step width as a duration string (e.g., "15s", "1m", "1h")'),
  summarize: z
    .string()
    .optional()
    .describe(
      'Optional intent for summarization. If provided, returns a summary of the query results instead of the raw data. Example: "Summarize CPU usage trends" or "Identify spikes in error rates"'
    ),
  collapsed: z
    .boolean()
    .optional()
    .default(true)
    .describe(
      'Whether to collapse the panel by default. Defaults to true. Set it to `false` if you think that this panel will be interesting to the user, for example if you think this is the only query in the conversation.'
    ),
  title: z.string().describe('The title of the query.'),
  description: z.string().describe('The description of the query.'),
});

export const prometheusRangeQueryTool = tool(
  async (input) => {
    const parsedInput = prometheusRangeQuerySchema.parse(input);
    const { datasource_uid, query, start, end, summarize, collapsed, title, description } = parsedInput;
    const datasource = await getDatasourceSrv().get({ uid: datasource_uid });
    if (!datasource) {
      throw new Error(`Datasource with uid ${datasource_uid} not found`);
    }
    const promDatasource = datasource as PrometheusDatasource;
    const timeRange = makeTimeRange(dateTime(start), dateTime(end));
    const defaultQuery = promDatasource.getDefaultQuery(CoreApp.Explore);
    const q = { ...defaultQuery, legendFormat: '__auto', expr: query, range: true, instant: false };
    const result = await lastValueFrom(
      promDatasource.query({
        requestId: '1',
        interval: '1m',
        intervalMs: 60000,
        range: timeRange,
        targets: [q],
        scopedVars: {},
        timezone: 'browser',
        app: CoreApp.Explore,
        startTime: timeRange.from.valueOf(),
      })
    );

    const panelJson = buildPanelJson(timeRange, 'timeseries', title, description, q, [], collapsed);

    // If summarize parameter is provided, use the LLM-based summarizer
    if (summarize) {
      return [
        await summarizePrometheusQueryResult('range', query, result, summarize, {
          from: timeRange.from.toISOString(),
          to: timeRange.to.toISOString(),
        }),
        panelJson,
      ];
    }

    // Otherwise return the raw result
    return [JSON.stringify(result), panelJson];
  },
  {
    name: 'prometheus_range_query',
    description: `
    Execute a Prometheus range query to evaluate a PromQL expression over a range of time.
    
    This tool provides two modes of operation:
    1. Data retrieval mode: Returns raw query results as JSON (default)
    2. Summarization mode: When 'summarize' parameter is provided, returns a human-readable summary
       with trend analysis and pattern detection based on the specified intent, generated by an advanced LLM
    
    Usage recommendations:
    - First use prometheus_metric_search to find relevant metrics and understand label cardinality
    - Only use range queries when you need to analyze trends or patterns over time
    - For simple current values, prefer prometheus_instant_query instead
    - Always use appropriate time ranges and steps to limit data volume
    - For complex time-series data, use the summarize parameter to get trend analysis
    
    Summarization examples:
    - "Summarize CPU usage trends over the period"
    - "Identify any spikes or anomalies in error rates"
    - "Analyze memory utilization patterns"
    `,
    schema: prometheusRangeQuerySchema,
    responseFormat: 'content_and_artifact',
    metadata: {
      explainer: () => {
        return `Running Prometheus range query`;
      },
    },
  }
);
