import { tool } from '@langchain/core/tools';
import { lastValueFrom } from 'rxjs';
import { z } from 'zod';

import { CoreApp, dateTime, makeTimeRange } from '@grafana/data';
import { getDataSourceSrv } from '@grafana/runtime';
import { LokiDatasource } from 'app/plugins/datasource/loki/datasource';
import { isLogsQuery, isQueryWithError } from 'app/plugins/datasource/loki/queryUtils';
import { LokiQuery, LokiQueryType } from 'app/plugins/datasource/loki/types';

import { buildPanelJson } from './buildPanelJson';
import { summarizeLokiQueryResult } from './lokiQuerySummarizer';
import { lokiTypeRefiner, unixTimestampRefiner } from './refiners';

const lokiRangeQuerySchema = z.object({
  datasource_uid: z
    .string()
    .describe('The datasource UID, only supports Loki datasource')
    .refine(lokiTypeRefiner.func, lokiTypeRefiner.message),
  query: z
    .string()
    .describe(
      '(REQUIRED) The LogQL query to execute. `{app="frontend"} | limit 10` is not valid in LogQL use tool parameter limit instead.'
    ),
  start: z
    .number()
    .describe('Start timestamp for the query range (Unix millisecond timestamp)')
    .refine(unixTimestampRefiner.func, unixTimestampRefiner.message),
  end: z
    .number()
    .describe('End timestamp for the query range (Unix millisecond timestamp)')
    .refine(unixTimestampRefiner.func, unixTimestampRefiner.message),
  limit: z
    .number()
    .optional()
    .default(100)
    .describe(
      'Maximum number of log lines to return (for log queries only, default is 100). This is is the only way to limit the number of logs in LogQL. | limit 100 is not valid in LogQL.'
    ),
  summarize: z
    .string()
    .optional()
    .describe(
      'Optional intent for summarization. If provided, returns a summary of the query results instead of the raw data. Example: "Summarize error patterns in logs" or "Identify traffic spikes in metrics"'
    ),
  collapsed: z
    .boolean()
    .optional()
    .default(true)
    .describe(
      'Whether to collapse the panel by default. Defaults to true. Set it to `false` if you think that this panel will be interesting to the user, for example if you think this is the only query in the conversation.'
    ),
  title: z.string().describe('The title of the query.'),
  description: z.string().describe('The description of the query.'),
});

export const lokiRangeQueryTool = tool(
  async (input) => {
    const parsedInput = lokiRangeQuerySchema.parse(input);
    const { datasource_uid, query, start, end, limit, summarize, collapsed, title, description } = parsedInput;

    // Get datasource
    const datasource = await getDataSourceSrv().get({ uid: datasource_uid });
    if (!datasource) {
      throw new Error(`Datasource with uid ${datasource_uid} not found`);
    }
    const lokiDatasource = datasource as LokiDatasource;

    // Set up time range
    const timeRange = makeTimeRange(dateTime(start), dateTime(end));

    if (isQueryWithError(query)) {
      return 'Failure. The generated query is not valid Loki LogQL syntax. Please double check and try again.';
    }

    // Detect if this is likely a logs query or a metric query
    const isLogsExpr = isLogsQuery(query);

    // Set up the query object
    const lokiQuery: LokiQuery = {
      expr: query,
      refId: 'A',
      queryType: LokiQueryType.Range,
      maxLines: limit,
    };

    // Run query
    const result = await lastValueFrom(
      lokiDatasource.query({
        requestId: '1',
        interval: '1m',
        intervalMs: 60000,
        range: timeRange,
        targets: [lokiQuery],
        scopedVars: {},
        timezone: 'browser',
        app: CoreApp.Explore,
        startTime: timeRange.from.valueOf(),
      })
    );

    let panelJson = null;
    if (!result.errors && result.data.length > 0 && result.data[0].length > 0) {
      lokiQuery.datasource = { uid: datasource_uid };
      panelJson = buildPanelJson(
        timeRange,
        isLogsExpr ? 'logs' : 'timeseries',
        title,
        description,
        lokiQuery,
        [],
        collapsed
      );
    }

    // If summarize parameter is provided, use the LLM-based summarizer
    if (summarize) {
      return [
        await summarizeLokiQueryResult('range', query, result, summarize, {
          from: timeRange.from.toISOString(),
          to: timeRange.to.toISOString(),
        }),
        panelJson,
      ];
    }

    // Otherwise return the raw result
    return [JSON.stringify(result), panelJson];
  },
  {
    name: 'loki_range_query',
    description: `
    Execute a Loki range query to evaluate a LogQL expression over a range of time.

    This tool provides two modes of operation:
    1. Data retrieval mode: Returns raw query results as JSON (default)
    2. Summarization mode: When 'summarize' parameter is provided, returns a human-readable summary
       with trend analysis and pattern detection based on the specified intent, generated by an advanced LLM

    You should most of the time use the summarize parameter to get a concise overview of the data. A summary is more efficient and easier to understand.

    This tool can query both logs and metrics from Loki:
    - For logs: Returns matching log lines with timestamps and labels
    - For metrics: Returns time series data for metric queries

    Usage recommendations:
    - When querying or search always try to limit the number of logs returned by 100 or less. Then if you need more increase the limit.
    - For simple log searches, use queries like '{app="myapp"} |= "error"'
    - For metrics, use aggregation operators like 'sum(rate({app="myapp"} |= "error" [5m]))'
    - Use appropriate time ranges to limit data volume
    - Set a reasonable limit for log queries to avoid overwhelming results
    - For complex data, use the summarize parameter to get trend analysis with relevant log examples
    - | limit 100 is not valid in LogQL use limit parameter instead.

    Summarization examples:
    - "Summarize error patterns in the application logs"
    - "Identify any spikes in HTTP error rates"
    - "Analyze response time trends over this period"
    `,
    schema: lokiRangeQuerySchema,
    metadata: {
      explainer: () => {
        return `run Loki range query`;
      },
    },
    verboseParsingErrors: true,
    responseFormat: 'content_and_artifact',
  }
);
